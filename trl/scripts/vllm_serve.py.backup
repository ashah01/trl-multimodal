# Copyright 2020-2025 The HuggingFace Team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import logging
import os
from collections.abc import Sequence
from contextlib import asynccontextmanager
from dataclasses import dataclass, field
from itertools import chain
from multiprocessing import Pipe, Process
from multiprocessing.connection import Connection
from typing import Optional, List, Dict, Any, Union, Tuple

from trl import TrlParser
from trl.import_utils import (
    is_fastapi_available,
    is_pydantic_available,
    is_uvicorn_available,
    is_vllm_ascend_available,
    is_vllm_available,
)

# Import DNA processing components with proper error handling
DNA_LLM_AVAILABLE = False
DLProcessor = None
DNAInput = None
CHAT_TEMPLATE = None

try:
    import torch
    import torch.nn as nn
    from transformers import (
        AutoTokenizer,
        AutoModelForCausalLM,
        AutoModelForMaskedLM,
        AutoConfig,
    )
    
    from bioreason.utils.dna_utils import DNAInput
    from bioreason.models.dl.processing_dl import DLProcessor
    from bioreason.models.dl.chat_template_dl import CHAT_TEMPLATE
    
    # Try to import Evo2 components
    try:
        from bioreason.models.evo2_tokenizer import Evo2Tokenizer, register_evo2_tokenizer
        register_evo2_tokenizer()
        EVO2_AVAILABLE = True
    except ImportError:
        EVO2_AVAILABLE = False
        print("Warning: Evo2 tokenizer not available")
    
    DNA_LLM_AVAILABLE = True
    print("✅ DNA-LLM components loaded successfully")
    
except ImportError as e:
    print(f"Warning: DNA-LLM components not available: {e}")
    print("DNA functionality will be disabled.")
    
    # Create minimal fallback classes
    class DNAInput:
        def __init__(self, sequence: str):
            self.sequence = sequence
    
    class DLProcessor:
        def __init__(self, *args, **kwargs):
            pass
        def __call__(self, *args, **kwargs):
            raise RuntimeError("DNA functionality not available - bioreason package not installed")
    
    CHAT_TEMPLATE = ""
    EVO2_AVAILABLE = False


if is_fastapi_available():
    from fastapi import FastAPI
else:
    FastAPI = None

if is_pydantic_available():
    from pydantic import BaseModel
else:
    BaseModel = None

if is_uvicorn_available():
    import uvicorn
else:
    uvicorn = None

if is_vllm_available():
    from vllm import LLM, SamplingParams
    from vllm.distributed.device_communicators.pynccl import PyNcclCommunicator
    from vllm.distributed.parallel_state import get_world_group
    from vllm.distributed.utils import StatelessProcessGroup
    from vllm.sampling_params import GuidedDecodingParams
    from vllm.utils import get_open_port

    if is_vllm_ascend_available():
        from vllm_ascend.distributed.device_communicators.pyhccl import PyHcclCommunicator as PyNcclCommunicator
else:
    LLM = None
    SamplingParams = None
    PyNcclCommunicator = None
    get_world_group = None
    StatelessProcessGroup = None
    GuidedDecodingParams = None
    get_open_port = None


logger = logging.getLogger(__name__)

# We use CUDA with multiprocessing, so we must use the 'spawn' start method
os.environ["VLLM_WORKER_MULTIPROC_METHOD"] = "spawn"
os.environ["VLLM_USE_V1"] = "0"


class WeightSyncWorkerExtension:
    """
    A vLLM worker extension that enables weight synchronization between a client and multiple server workers.
    """

    # The following attributes are initialized when `init_communicator` method is called.
    pynccl_comm = None  # Communicator for weight updates
    client_rank = None  # Source rank for broadcasting updated weights

    def init_communicator(self, host: str, port: int, world_size: int) -> None:
        """Initialize the weight update communicator using a stateless process group."""
        if self.pynccl_comm is not None:
            raise RuntimeError("Weight update group already initialized. Call close_communicator first.")

        # Get the rank of the current worker in the global world group.
        rank = get_world_group().rank

        # Create a stateless process group to manage communication
        pg = StatelessProcessGroup.create(host=host, port=port, rank=rank, world_size=world_size)

        # Initialize the NCCL-based communicator for weight synchronization.
        self.pynccl_comm = PyNcclCommunicator(pg, device=self.device)

        # The client process that sends updated weights has the highest rank
        self.client_rank = world_size - 1

    def update_named_param(self, name: str, dtype, shape: Sequence[int]) -> None:
        """Receive updated weights from the client process and update the named parameter in the model."""
        if self.pynccl_comm is None:
            raise RuntimeError("Communicator not initialized. Call `init_communicator` first.")

        # Allocate memory for the incoming weight tensor on the correct device.
        weight = torch.empty(shape, dtype=dtype, device=self.device)

        # Use NCCL to broadcast the updated weights from the client (src) to all workers.
        self.pynccl_comm.broadcast(weight, src=self.client_rank)
        self.pynccl_comm.group.barrier()

        # Load the received weights into the model.
        self.model_runner.model.load_weights(weights=[(name, weight)])

    def close_communicator(self) -> None:
        """Close the communicator when weight synchronization is no longer needed."""
        if self.pynccl_comm is not None:
            del self.pynccl_comm
            self.pynccl_comm = None
            self.client_rank = None


@dataclass
class ScriptArguments:
    """Arguments for the vLLM serve script."""
    model: str = field(metadata={"help": "Model name or path to load the model from."})
    revision: Optional[str] = field(default=None, metadata={"help": "Revision to use for the model."})
    tensor_parallel_size: int = field(default=1, metadata={"help": "Number of tensor parallel workers to use."})
    data_parallel_size: int = field(default=1, metadata={"help": "Number of data parallel workers to use."})
    host: str = field(default="0.0.0.0", metadata={"help": "Host address to run the server on."})
    port: int = field(default=8000, metadata={"help": "Port to run the server on."})
    gpu_memory_utilization: float = field(default=0.5, metadata={"help": "GPU memory utilization ratio for vLLM."})
    dtype: str = field(default="auto", metadata={"help": "Data type to use for vLLM generation."})
    max_model_len: Optional[int] = field(default=None, metadata={"help": "Maximum model length for vLLM."})
    enable_prefix_caching: Optional[bool] = field(default=None, metadata={"help": "Whether to enable prefix caching in vLLM."})
    enforce_eager: Optional[bool] = field(default=False, metadata={"help": "Whether to enforce eager execution."})
    kv_cache_dtype: str = field(default="auto", metadata={"help": "Data type to use for KV cache."})
    trust_remote_code: bool = field(default=False, metadata={"help": "Whether to trust remote code when loading models."})
    log_level: str = field(default="info", metadata={"help": "Log level for uvicorn."})
    
    # DNA-specific parameters
    dna_model_name: Optional[str] = field(default=None, metadata={"help": "DNA model name or path for multimodal DNA+text generation."})
    dna_is_evo2: bool = field(default=False, metadata={"help": "Whether the DNA model is Evo2."})
    dna_embedding_layer: Optional[str] = field(default=None, metadata={"help": "Name of the layer to use for the Evo2 model."})
    max_length_dna: int = field(default=2048, metadata={"help": "Maximum length of DNA sequences."})
    use_dna_llm: bool = field(default=False, metadata={"help": "Whether to enable DNA processing for multimodal DNA+text generation."})


def llm_worker(script_args: ScriptArguments, data_parallel_rank: int, master_port: int, connection: Connection) -> None:
    """Worker process for handling vLLM generation with optional DNA processing."""
    # Set required environment variables for DP to work with vLLM
    os.environ["VLLM_DP_RANK"] = str(data_parallel_rank)
    os.environ["VLLM_DP_RANK_LOCAL"] = str(data_parallel_rank)
    os.environ["VLLM_DP_SIZE"] = str(script_args.data_parallel_size)
    os.environ["VLLM_DP_MASTER_PORT"] = str(master_port)

    # Always use standard vLLM for hosting
    llm = LLM(
        model=script_args.model,
        revision=script_args.revision,
        tensor_parallel_size=script_args.tensor_parallel_size,
        gpu_memory_utilization=script_args.gpu_memory_utilization,
        enforce_eager=script_args.enforce_eager,
        dtype=script_args.dtype,
        enable_prefix_caching=script_args.enable_prefix_caching,
        kv_cache_dtype=script_args.kv_cache_dtype,
        max_model_len=script_args.max_model_len,
        worker_extension_cls="trl.scripts.vllm_serve.WeightSyncWorkerExtension",
        trust_remote_code=script_args.trust_remote_code,
        enable_prompt_embeds=True,
    )

    # Initialize DNA processing components if needed
    dna_processor = None
    if script_args.use_dna_llm and DNA_LLM_AVAILABLE and script_args.dna_model_name:
        try:
            dna_processor = DNAEmbeddingProcessor(
                dna_model_name=script_args.dna_model_name,
                text_model_name=script_args.model,
                dna_is_evo2=script_args.dna_is_evo2,
                dna_embedding_layer=script_args.dna_embedding_layer,
                max_length_dna=script_args.max_length_dna,
            )
            print("✅ DNA processor initialized successfully")
        except Exception as e:
            print(f"❌ Failed to initialize DNA processor: {e}")
            dna_processor = None

    # Send ready signal to parent process
    connection.send({"status": "ready"})

    while True:
        try:
            command = connection.recv()
        except KeyboardInterrupt:
            if hasattr(llm, 'collective_rpc'):
                llm.collective_rpc(method="close_communicator")
            break

        # Handle commands
        if command["type"] in ["call", "fire_and_forget"]:
            method_name = command["method"]
            args, kwargs = command.get("args", ()), command.get("kwargs", {})
            
            # Handle DNA-enhanced generation
            if method_name == "generate" and dna_processor is not None:
                result = generate_with_dna_embeddings(llm, dna_processor, kwargs)
            else:
                # Standard vLLM handling
                method = getattr(llm, method_name)
                result = method(*args, **kwargs)
                
            if command["type"] == "call":
                connection.send(result)
        elif command["type"] == "shutdown":
            break


def chunk_list(lst: list, n: int) -> list:
    """Split list `lst` into `n` evenly distributed sublists."""
    k, r = divmod(len(lst), n)
    return [lst[i * k + min(i, r) : (i + 1) * k + min(i + 1, r)] for i in range(n)]


class DNAEmbeddingProcessor:
    """
    DNA embedding processor that replicates DNALLMModel's DNA processing functionality.
    Based exactly on the reference DNALLMModel implementation.
    """
    
    def __init__(
        self,
        dna_model_name: str,
        text_model_name: str,
        dna_is_evo2: bool = False,
        dna_embedding_layer: Optional[str] = None,
        max_length_dna: int = 2048,
    ):
        if not DNA_LLM_AVAILABLE:
            raise RuntimeError("DNA-LLM components not available. Please install bioreason package.")
        
        print(f"🧬 Initializing DNAEmbeddingProcessor...")
        print(f"  DNA model: {dna_model_name}")
        print(f"  Text model: {text_model_name}")
        print(f"  Evo2: {dna_is_evo2}")
        print(f"  Embedding layer: {dna_embedding_layer}")
        
        self.dna_is_evo2 = dna_is_evo2
        self.dna_embedding_layer = dna_embedding_layer
        self.max_length_dna = max_length_dna
        
        # STEP 1: Load DNA model and tokenizer (exactly like DNALLMModel)
        print("🧬 Loading DNA model and tokenizer...")
        if not self.dna_is_evo2:
            self.dna_model = AutoModelForMaskedLM.from_pretrained(
                dna_model_name, trust_remote_code=True
            )
            self.dna_tokenizer = AutoTokenizer.from_pretrained(dna_model_name, trust_remote_code=True)
            self.dna_config = self.dna_model.config
        else:
            if not EVO2_AVAILABLE:
                raise ImportError("Evo2 is required when dna_is_evo2=True. Please install the evo2 package.")
            try:
                from evo2 import Evo2
                self.dna_model = Evo2(dna_model_name)
                self.dna_tokenizer = Evo2Tokenizer(self.dna_model.tokenizer)
                self.dna_config = self.dna_model.model.config
            except ImportError:
                raise ImportError("Evo2 is required when dna_is_evo2=True. Please install the evo2 package.")
        
        print("✅ DNA model loaded successfully")

        # STEP 2: Load text model config and tokenizer (exactly like DNALLMModel)
        print("📝 Loading text tokenizer...")
        self.text_tokenizer = AutoTokenizer.from_pretrained(text_model_name, trust_remote_code=True)
        self.text_config = AutoConfig.from_pretrained(text_model_name, trust_remote_code=True)

        # Use the same chat template as DNALLMModel
        self.text_tokenizer.chat_template = CHAT_TEMPLATE
        self.text_tokenizer.pad_token = self.text_tokenizer.eos_token

        # Add DNA tokens exactly like DNALLMModel
        new_tokens = ["<|dna_start|>", "<|dna_pad|>", "<|dna_end|>"]
        self.text_tokenizer.add_special_tokens({"additional_special_tokens": new_tokens})
        self.dna_token_id = self.text_tokenizer.convert_tokens_to_ids("<|dna_pad|>")

        print("✅ Text tokenizer loaded successfully")

        # STEP 3: Create projection layer (exactly like DNALLMModel)
        print("🔗 Creating DNA projection layer...")
        self.text_hidden_size = self.text_config.hidden_size
        self.dna_hidden_size = self.dna_config.hidden_size
        self.dna_projection = nn.Linear(self.dna_hidden_size, self.text_hidden_size)
        print(f"✅ Projection layer created: {self.dna_hidden_size} -> {self.text_hidden_size}")

        # STEP 4: Load custom components (exactly like DNALLMModel)
        print("🔧 Loading custom projection weights...")
        self.load_custom_components(text_model_name)

        # STEP 5: Create processor (exactly like DNALLMModel)
        self.processor = DLProcessor(tokenizer=self.text_tokenizer, dna_tokenizer=self.dna_tokenizer)

        # STEP 6: Create minimal embedding layer for text embeddings
        self._embedding_layer = None
        self._text_model_name = text_model_name

        print("✅ DNAEmbeddingProcessor initialized successfully")
    
    def load_custom_components(self, llm_dir: str) -> None:
        """Load trained DNA projection weights (exactly like DNALLMModel)."""
        import os
        
        # Try to load DNA projection layer weights
        projection_path = os.path.join(llm_dir, 'dna_projection.pt')
        if os.path.exists(projection_path):
            print(f"🔧 Loading trained DNA projection weights from {projection_path}")
            try:
                projection_state = torch.load(projection_path, map_location='cpu')
                
                # Check if we can load the weights
                if self.dna_projection.weight.shape == projection_state['weight'].shape:
                    self.dna_projection.load_state_dict(projection_state)
                    print("✅ Trained DNA projection weights loaded successfully")
                else:
                    print(f"⚠️ Projection layer shape mismatch!")
                    print(f"  Expected: {self.dna_projection.weight.shape}")
                    print(f"  Found: {projection_state['weight'].shape}")
                    print("  Using randomly initialized projection layer")
            except Exception as e:
                print(f"⚠️ Error loading projection weights: {e}")
                print("  Using randomly initialized projection layer")
        else:
            print(f"⚠️ No trained DNA projection weights found at {projection_path}")
            print("  Using randomly initialized projection layer (may affect quality)")
        
        # Check if there's a local DNA model (optional)
        dna_model_path = os.path.join(llm_dir, 'dna_model')
        if os.path.exists(dna_model_path) and not self.dna_is_evo2:
            print(f"📁 Found local DNA model at {dna_model_path}")
            try:
                # Replace the DNA model with the local one
                self.dna_model = AutoModelForMaskedLM.from_pretrained(dna_model_path, trust_remote_code=True)
                self.dna_tokenizer = AutoTokenizer.from_pretrained(dna_model_path, trust_remote_code=True)
                self.dna_config = self.dna_model.config
                print("✅ Local DNA model loaded successfully")
            except Exception as e:
                print(f"⚠️ Error loading local DNA model: {e}")
                print("  Using original DNA model")
    
    def get_text_embeddings(self, input_ids: torch.Tensor) -> torch.Tensor:
        """Get text embeddings (exactly like DNALLMModel)."""
        if self._embedding_layer is None:
            print("⚠️ Creating minimal embedding layer for DNA integration...")
            # Create embedding layer exactly like DNALLMModel
            embed_dim = self.text_config.hidden_size
            vocab_size = self.text_config.vocab_size
            self._embedding_layer = nn.Embedding(vocab_size, embed_dim)
            
            # Try to load embedding weights exactly like DNALLMModel
            try:
                import os
                model_path = self._text_model_name
                if os.path.exists(model_path):
                    # Load just the embedding weights from safetensors
                    try:
                        import safetensors
                        from safetensors import safe_open
                        
                        # Try safetensors first
                        safetensors_path = os.path.join(model_path, "model.safetensors")
                        if os.path.exists(safetensors_path):
                            with safe_open(safetensors_path, framework="pt", device="cpu") as f:
                                embed_weights = f.get_tensor("model.embed_tokens.weight")
                                self._embedding_layer.weight.data = embed_weights
                                print("✅ Loaded embedding weights from safetensors")
                        else:
                            # Try multiple safetensors files (for sharded models)
                            import glob
                            shard_files = glob.glob(os.path.join(model_path, "model-*.safetensors"))
                            if shard_files:
                                for shard_file in shard_files:
                                    try:
                                        with safe_open(shard_file, framework="pt", device="cpu") as f:
                                            if "model.embed_tokens.weight" in f.keys():
                                                embed_weights = f.get_tensor("model.embed_tokens.weight")
                                                self._embedding_layer.weight.data = embed_weights
                                                print("✅ Loaded embedding weights from sharded safetensors")
                                                break
                                    except:
                                        continue
                    except Exception as e:
                        print(f"⚠️ Could not load from safetensors: {e}")
                        print("   Using randomly initialized embeddings")
            except Exception as e:
                print(f"⚠️ Could not load embedding weights: {e}")
                print("   Using randomly initialized embeddings")
            
            self._embedding_layer.to(input_ids.device)
        
        return self._embedding_layer(input_ids)
    
    def process_dna_embeddings(
        self,
        dna_tokenized: Dict[str, torch.Tensor],
        batch_idx_map: List[int],
        batch_size: int,
    ) -> List[torch.Tensor]:
        """Process DNA sequences to obtain embeddings (exactly like DNALLMModel)."""
        print(f"🧬 Processing DNA embeddings for {len(dna_tokenized['input_ids'])} sequences")
        
        # Process all sequences to get DNA representations
        with torch.no_grad():
            # Handle different model types based on dna_is_evo2 attribute (same as DNALLMModel)
            if self.dna_is_evo2 and self.dna_embedding_layer is not None:  # Evo2 model
                print(f"🧬 Using Evo2 model with embedding layer: {self.dna_embedding_layer}")
                # Get embeddings from the specific layer in Evo2
                hidden_states_list = []
                
                for seq_idx in range(len(dna_tokenized["input_ids"])):
                    # Extract single sequence
                    input_ids = dna_tokenized["input_ids"][seq_idx:seq_idx+1]
                    
                    # Call Evo2 with return_embeddings=True
                    _, embeddings = self.dna_model(
                        input_ids,
                        return_embeddings=True,
                        layer_names=[self.dna_embedding_layer]
                    )
                    
                    # Get embeddings for the specified layer
                    seq_embeddings = embeddings[self.dna_embedding_layer].squeeze(0)
                    hidden_states_list.append(seq_embeddings)
                
                # Stack to get same format as non-Evo2 output
                if hidden_states_list:
                    hidden_states = torch.stack(hidden_states_list)
                else:
                    return [torch.zeros((0, self.text_hidden_size)) for _ in range(batch_size)]
                    
            else:  # Standard HuggingFace model (same as DNALLMModel)
                print(f"🧬 Using standard HuggingFace DNA model")
                # Use existing code path for HF models
                outputs = self.dna_model(
                    input_ids=dna_tokenized["input_ids"],
                    attention_mask=dna_tokenized["attention_mask"],
                    output_hidden_states=True,
                )
                # Get the last hidden state
                hidden_states = outputs.hidden_states[-1]  # shape: [n_seqs, seq_len, hidden_dim]

        print(f"🧬 Raw DNA hidden states shape: {hidden_states.shape}")
        
        # Project all embeddings at once (same as DNALLMModel)
        hidden_states = hidden_states.to(device=self.dna_projection.weight.device, dtype=self.dna_projection.weight.dtype)
        projected_states = self.dna_projection(hidden_states)
        
        print(f"🧬 Projected DNA states shape: {projected_states.shape}")

        # Group embeddings by batch item (same as DNALLMModel)
        result: List[torch.Tensor] = []

        # For each batch item, collect its embeddings
        for batch_idx in range(batch_size):
            batch_embeddings = []
            for seq_idx, seq_batch_idx in enumerate(batch_idx_map):
                if seq_batch_idx == batch_idx:
                    # Get only the valid (non-padding) tokens
                    valid_length = dna_tokenized["attention_mask"][seq_idx].sum().item()
                    seq_embedding = projected_states[seq_idx, :valid_length]
                    batch_embeddings.append(seq_embedding)

            # Concatenate embeddings for this batch item
            if batch_embeddings:
                batch_result = torch.cat(batch_embeddings, dim=0)
                result.append(batch_result)
                print(f"🧬 Batch {batch_idx} DNA embeddings shape: {batch_result.shape}")
            else:
                empty_result = torch.zeros((0, self.text_hidden_size))
                result.append(empty_result)
                print(f"🧬 Batch {batch_idx} has no DNA embeddings")

        return result


def generate_with_dna_embeddings(llm, dna_processor, kwargs):
    """Generate using standard vLLM with DNA embeddings (exactly like DNALLMModel.generate)."""
    print(f"🧬 generate_with_dna_embeddings called with kwargs keys: {kwargs.keys()}")
    
    if "inputs" in kwargs:
        # DNA+text inputs format
        inputs = kwargs["inputs"]
        print(f"🧬 Processing {len(inputs)} input samples")
        
        # Use processor to prepare inputs (exactly like DNALLMModel)
        processed = dna_processor.processor(inputs)
        
        # Get input_ids and attention_mask
        input_ids = processed["input_ids"]
        attention_mask = processed["attention_mask"]
        
        print(f"🧬 Input IDs shape: {input_ids.shape}")
        
        # Check if we have DNA data
        if "dna_tokenized" in processed and processed["dna_tokenized"]:
            print(f"🧬 ✅ DNA data provided - processing DNA embeddings...")
            
            batch_size = input_ids.shape[0]
            dna_embeddings = dna_processor.process_dna_embeddings(
                processed["dna_tokenized"],
                processed["batch_idx_map"],
                batch_size
            )
            
            # Get text embeddings (exactly like DNALLMModel)
            text_embeddings = dna_processor.get_text_embeddings(input_ids)
            print(f"🧬 Text embeddings shape: {text_embeddings.shape}")
            
            # Integrate DNA embeddings (exact same logic as DNALLMModel.generate)
            mask = input_ids == dna_processor.dna_token_id
            n_dna_tokens = mask.sum().item()
            dna_embeds_flat = torch.cat(dna_embeddings, dim=0)
            n_dna_features = dna_embeds_flat.shape[0]
            
            print(f"🧬 Found {n_dna_tokens} DNA tokens in text")
            print(f"🧬 Generated {n_dna_features} DNA features")

            if n_dna_features != n_dna_tokens:
                raise ValueError(
                    f"DNA features and DNA tokens do not match: features {n_dna_features}, tokens: {n_dna_tokens}"
                )

            # Ensure DNA embeddings have the same dtype as the text embeddings
            dna_embeds_flat = dna_embeds_flat.to(dtype=text_embeddings.dtype, device=text_embeddings.device)
            
            print(f"🧬 Before DNA replacement - text embeds mean: {text_embeddings.mean().item():.4f}")
            text_embeddings[mask] = dna_embeds_flat
            print(f"🧬 After DNA replacement - text embeds mean: {text_embeddings.mean().item():.4f}")
            print(f"🧬 DNA successfully integrated into text embeddings!")
            
            # Process each batch item separately for vLLM (exactly like DNALLMModel)
            sampling_params = kwargs.get("sampling_params", SamplingParams())
            all_outputs = []
            
            print(f"🧬 ======= PROMPT EMBEDS ANALYSIS =======")
            print(f"🧬 Input text_embeddings shape: {text_embeddings.shape}")
            print(f"🧬 Input text_embeddings dtype: {text_embeddings.dtype}")
            print(f"🧬 Input text_embeddings device: {text_embeddings.device}")
            print(f"🧬 Input batch_size: {batch_size}")
            
            if text_embeddings.dim() == 3:
                # Process each batch item separately (exactly like DNALLMModel)
                print(f"🧬 3D tensor detected - processing each batch item separately")
                
                for batch_idx in range(text_embeddings.shape[0]):
                    single_embeddings = text_embeddings[batch_idx]  # (seq_len, hidden_size)
                    print(f"🧬 Generating for batch {batch_idx} with embeddings shape: {single_embeddings.shape}")
                    
                    with torch.no_grad():
                        batch_outputs = llm.generate(
                            {"prompt_embeds": single_embeddings},
                            sampling_params
                        )
                    all_outputs.extend(batch_outputs)
            elif text_embeddings.dim() == 2:
                # Single item format
                print(f"🧬 2D tensor detected - single item format")
                with torch.no_grad():
                    all_outputs = llm.generate(
                        {"prompt_embeds": text_embeddings},
                        sampling_params
                    )
            else:
                raise ValueError(f"Unexpected embedding dimensions: {text_embeddings.dim()}D")
            
            return all_outputs
        else:
            # Text-only generation
            prompts = [inp["text"] for inp in inputs]
            sampling_params = kwargs.get("sampling_params", SamplingParams())
            print(f"🧬 Text-only generation for {len(prompts)} prompts")
            return llm.generate(prompts, sampling_params)
    else:
        # Standard vLLM prompts format - no DNA processing needed
        prompts = kwargs.get("prompts", [])
        sampling_params = kwargs.get("sampling_params", SamplingParams())
        print(f"🧬 Standard vLLM generation for {len(prompts)} prompts")
        return llm.generate(prompts, sampling_params)


def main(script_args: ScriptArguments):
    """Main function to start the vLLM serve with DNA support."""
    # Check required dependencies
    if not is_fastapi_available():
        raise ImportError("FastAPI is required. Install with: pip install fastapi")
    if not is_pydantic_available():
        raise ImportError("Pydantic is required. Install with: pip install pydantic")
    if not is_uvicorn_available():
        raise ImportError("Uvicorn is required. Install with: pip install uvicorn")
    if not is_vllm_available():
        raise ImportError("vLLM is required. Install with: pip install vllm")

    # Spawn dp workers, and setup pipes for communication
    master_port = get_open_port()
    connections = []
    processes = []
    for data_parallel_rank in range(script_args.data_parallel_size):
        parent_connection, child_connection = Pipe()
        process = Process(target=llm_worker, args=(script_args, data_parallel_rank, master_port, child_connection))
        process.start()
        connections.append(parent_connection)
        processes.append(process)

    @asynccontextmanager
    async def lifespan(app: FastAPI):
        # Wait for all workers to send "ready"
        ready_connections = set()
        while len(ready_connections) < script_args.data_parallel_size:
            for connection in connections:
                msg = connection.recv()
                if isinstance(msg, dict) and msg.get("status") == "ready":
                    ready_connections.add(connection)

        yield

        # Wait for processes to terminate
        for process in processes:
            process.join(timeout=10)
            if process.is_alive():
                logger.warning(f"Process {process} is still alive after 10 seconds, attempting to terminate...")
                process.terminate()
                process.join()

    app = FastAPI(lifespan=lifespan)

    # Health check endpoint
    @app.get("/health/")
    async def health():
        """Health check endpoint to verify that the server is running."""
        return {"status": "ok"}

    @app.get("/get_world_size/")
    async def get_world_size():
        """Retrieves the world size of the LLM engine."""
        return {"world_size": script_args.tensor_parallel_size * script_args.data_parallel_size}

    class GenerateRequest(BaseModel):
        prompts: List[str]
        dna_sequences: Optional[List[List[str]]] = None  # List of DNA sequences per prompt
        n: int = 1
        repetition_penalty: float = 1.0
        temperature: float = 1.0
        top_p: float = 1.0
        top_k: int = -1
        min_p: float = 0.0
        max_tokens: int = 16
        guided_decoding_regex: Optional[str] = None
        generation_kwargs: Dict = field(default_factory=dict)

    class GenerateResponse(BaseModel):
        completion_ids: List[List[int]]

    @app.post("/generate/", response_model=GenerateResponse)
    async def generate(request: GenerateRequest):
        """Generate completions for the provided prompts, with optional DNA sequences."""
        # Check if we're using DNA processing
        if script_args.use_dna_llm and DNA_LLM_AVAILABLE and script_args.dna_model_name:
            return await generate_with_dna_processing(request)
        else:
            return await generate_with_vllm(request)

    async def generate_with_dna_processing(request: GenerateRequest):
        """Generate using standard vLLM with DNA embeddings processed by DNAEmbeddingProcessor."""
        # Build generation kwargs for vLLM
        generation_kwargs = {
            "temperature": request.temperature,
            "top_p": request.top_p,
            "max_tokens": request.max_tokens,
            "repetition_penalty": request.repetition_penalty,
            "top_k": request.top_k,
            "min_p": request.min_p,
        }
        if request.guided_decoding_regex is not None:
            generation_kwargs["guided_decoding"] = GuidedDecodingParams(backend="outlines", regex=request.guided_decoding_regex)
        
        generation_kwargs.update(request.generation_kwargs)
        sampling_params = SamplingParams(**generation_kwargs)

        # Evenly distribute prompts and DNA sequences across DP ranks
        chunked_prompts = chunk_list(request.prompts, script_args.data_parallel_size)
        
        # Handle DNA sequences if provided
        if request.dna_sequences:
            chunked_dna = chunk_list(request.dna_sequences, script_args.data_parallel_size)
        else:
            chunked_dna = [[] for _ in range(script_args.data_parallel_size)]

        # Send the prompts and DNA sequences to each worker
        for connection, prompts, dna_seqs in zip(connections, chunked_prompts, chunked_dna):
            # When the number of prompts is less than data_parallel_size, some workers will receive empty prompts.
            if not prompts:
                prompts = ["<placeholder>"]
                dna_seqs = []

            # Prepare inputs for DNA processing (exactly like DNALLMModel)
            inputs = []
            for i, prompt in enumerate(prompts):
                dna_for_prompt = dna_seqs[i] if i < len(dna_seqs) else []
                
                # Create DNAInput objects for each DNA sequence
                dna_inputs = [DNAInput(sequence=seq) for seq in dna_for_prompt] if dna_for_prompt else []
                
                inputs.append({
                    "text": prompt,
                    "dna_sequences": dna_inputs
                })

            kwargs = {
                "inputs": inputs,
                "sampling_params": sampling_params
            }
            connection.send({"type": "call", "method": "generate", "kwargs": kwargs})

        # Receive results
        all_outputs = [connection.recv() for connection in connections]

        # Handle empty prompts
        all_outputs = [output for output, prompts in zip(all_outputs, chunked_prompts) if prompts]

        # Process vLLM outputs
        all_outputs = list(chain.from_iterable(all_outputs))
        completion_ids = [list(output.token_ids) for outputs in all_outputs for output in outputs.outputs]
        return {"completion_ids": completion_ids}

    async def generate_with_vllm(request: GenerateRequest):
        """Generate using standard vLLM (original logic)."""
        # Guided decoding, if enabled
        if request.guided_decoding_regex is not None:
            guided_decoding = GuidedDecodingParams(backend="outlines", regex=request.guided_decoding_regex)
        else:
            guided_decoding = None

        generation_kwargs = {
            "n": request.n,
            "repetition_penalty": request.repetition_penalty,
            "temperature": request.temperature,
            "top_p": request.top_p,
            "top_k": request.top_k,
            "min_p": request.min_p,
            "max_tokens": request.max_tokens,
            "guided_decoding": guided_decoding,
        }
        generation_kwargs.update(request.generation_kwargs)
        sampling_params = SamplingParams(**generation_kwargs)

        # Evenly distribute prompts across DP ranks
        chunked_prompts = chunk_list(request.prompts, script_args.data_parallel_size)

        # Send the prompts to each worker
        for connection, prompts in zip(connections, chunked_prompts):
            if not prompts:
                prompts = ["<placeholder>"]
            kwargs = {"prompts": prompts, "sampling_params": sampling_params}
            connection.send({"type": "call", "method": "generate", "kwargs": kwargs})

        # Receive results
        all_outputs = [connection.recv() for connection in connections]

        # Handle empty prompts
        all_outputs = [output for output, prompts in zip(all_outputs, chunked_prompts) if prompts]

        # Flatten and combine all results
        all_outputs = list(chain.from_iterable(all_outputs))
        completion_ids = [list(output.token_ids) for outputs in all_outputs for output in outputs.outputs]
        return {"completion_ids": completion_ids}

    # Additional endpoints (init_communicator, update_named_param, etc.)
    class InitCommunicatorRequest(BaseModel):
        host: str
        port: int
        world_size: int

    @app.post("/init_communicator/")
    async def init_communicator(request: InitCommunicatorRequest):
        """Initialize the communicator for synchronizing model weights."""
        world_size = script_args.tensor_parallel_size * script_args.data_parallel_size + 1
        kwargs = {"method": "init_communicator", "args": (request.host, request.port, world_size)}
        for connection in connections:
            connection.send({"type": "fire_and_forget", "method": "collective_rpc", "kwargs": kwargs})
        return {"message": "Request received, initializing communicator"}

    class UpdateWeightsRequest(BaseModel):
        name: str
        dtype: str
        shape: List[int]

    @app.post("/update_named_param/")
    async def update_named_param(request: UpdateWeightsRequest):
        """Update the model weights with the provided tensor."""
        dtype = torch.__getattribute__(request.dtype.split(".")[-1])
        kwargs = {"method": "update_named_param", "args": (request.name, dtype, tuple(request.shape))}
        for connection in connections:
            connection.send({"type": "fire_and_forget", "method": "collective_rpc", "kwargs": kwargs})
        return {"message": "Request received, updating named parameter"}

    @app.post("/reset_prefix_cache/")
    async def reset_prefix_cache():
        """Reset the prefix cache for the model."""
        for connection in connections:
            connection.send({"type": "call", "method": "reset_prefix_cache"})
        all_outputs = [connection.recv() for connection in connections]
        success = all(output for output in all_outputs)
        return {"message": "Request received, resetting prefix cache status: " + str(success)}

    @app.post("/close_communicator/")
    async def close_communicator():
        """Close the weight update group and clean up associated resources."""
        kwargs = {"method": "close_communicator"}
        for connection in connections:
            connection.send({"type": "fire_and_forget", "method": "collective_rpc", "kwargs": kwargs})
        return {"message": "Request received, closing communicator"}

    # Start the server
    uvicorn.run(app, host=script_args.host, port=script_args.port, log_level=script_args.log_level)


def make_parser(subparsers=None):
    """Create argument parser for the vLLM serve script."""
    if subparsers is not None:
        parser = subparsers.add_parser("vllm-serve", help="Run the vLLM serve script", dataclass_types=ScriptArguments)
    else:
        parser = TrlParser(ScriptArguments)
    return parser


if __name__ == "__main__":
    parser = make_parser()
    (script_args,) = parser.parse_args_and_config()
    main(script_args)
